<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"caller.js.html":{"id":"caller.js.html","title":"Source: caller.js","body":" soundpad.js Classes CallerSoundpad Source: caller.js class Caller { /** * @constructor * @param {Soundpad} soundpad - Connected Soundpad instance to send command. */ constructor(soundpad) { this.soundpad = soundpad; } } module.exports = Caller; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" soundpad.js Classes CallerSoundpad Source: index.js import net from 'net'; import * as _ from 'lodash'; const Promise = require('bluebird'); const log = require('debug')(__filename); const pipeName = '\\\\\\\\.\\\\pipe\\\\sp_remote_control'; const tracker = log.extend('trace'); tracker.log = (data, ...args) =&gt; { console.error('Function %s was called', data, ...args); }; class Soundpad { /** * @constructor * @param {object} connectionSettings - Settings of connecting Soundpad */ constructor(connectionSettings) { tracker('constructor'); this.connected = false; this.pipe = false; this.intervalTimeout = false; this.writing = false; connectionSettings = _.defaults(connectionSettings, { autoReconnect: true, pollingInterval: 1000, reconnectInterval: 1000, timeout: 1000 }); this.autoReconnect = connectionSettings.autoReconnect; this.connectionTimeout = connectionSettings.timeout; this.pollingInterval = connectionSettings.pollingInterval; this.reconnectInterval = connectionSettings.reconnectInterval; this.timeout = connectionSettings.timeout; } /** * Connects to Soundpad * @returns {Promise} Resolves the Soundpad instance when connected Soundpad successfully */ connect() { tracker('connect'); return new Promise((resolve, reject) =&gt; { if (this.connected) { reject(new Error('Soundpad already connected')); } const socket = net.createConnection({ path: pipeName, timeout: this.timeout }, () =&gt; { socket.removeAllListeners(); this.pipe = socket; this.connected = true; this.intervalTimeout = setInterval(this.poll, this.pollingInterval); resolve(this); }); socket.on('error', () =&gt; { if (this.autoReconnect) { Promise.delay(this.reconnectInterval).then(() =&gt; { this.connect().then(() =&gt; { return this; }); }); } else { reject(new Error('Soundpad could not be connected')); } }); }); } /** * Disconnects Soundpad * @returns {Promise} Resolves the Soundpad instance when disconnected Soundpad successfully. */ disconnect() { tracker('disconnect'); return new Promise((resolve, reject) =&gt; { if (this.connected) { clearInterval(this.intervalTimeout); this.pipe.end(); this.pipe = false; resolve(this); } else { reject(new Error('Soundpad is not connected or not a socket')); } }); } /** * Poll Soundpad * @returns {Promise} Resolves the Soundpad instance when Soundpad respond */ poll() { tracker('poll'); return new Promise((resolve, reject) =&gt; { this.send('IsAlive()').then(() =&gt; { resolve(this); }, error =&gt; { reject(error); }); }); } /** * Send `data` to Soundpad * @param {string|Buffer|Uint8Array} data - Data which will be sent. * @param {boolean} hasResponse - Wait until Soundpad respond? * @returns {Promise} Resolves response if `hasResponse` is `true`, * or resolves the Soundpad instance when the data is sent */ send(data, hasResponse = false) { tracker('send'); return new Promise((resolve, reject) =&gt; { if (this.writing) { reject(new Error('Cannot send data while other data is being sent')); } if (this.connected) { this.writing = true; if (typeof data === 'string') { data = Buffer.from(data); } if (hasResponse) { this.pipe.on('data', data =&gt; { this.pipe.removeAllListeners('data'); this.writing = false; resolve(data); }); } this.pipe.write(data, 'utf8', () =&gt; { if (!hasResponse) { this.writing = false; resolve(this); } }); if (this.writing) { reject(new Error('Could not be sent to Soundpad')); } } else { reject(new Error('Soundpad is not connected or not a socket')); } }); } } module.exports = Soundpad; module.exports.pipeName = pipeName; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" soundpad.js Classes CallerSoundpad Classes Classes Caller Soundpad × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" soundpad.js Classes CallerSoundpad soundpad.js A Node.js module to interact with Soundpad Features Supports Promise (even in constructor) Installation npm install mcpe-pc/soundpad.js Not published: npm: npm install soundpad Yarn: yarn add soundpad × Search results Close "},"Caller.html":{"id":"Caller.html","title":"Class: Caller","body":" soundpad.js Classes CallerSoundpad Class: Caller Caller new Caller(soundpad) Parameters: Name Type Description soundpad Soundpad Connected Soundpad instance to send command. Source: caller.js, line 6 × Search results Close "},"Soundpad.html":{"id":"Soundpad.html","title":"Class: Soundpad","body":" soundpad.js Classes CallerSoundpad Class: Soundpad Soundpad new Soundpad(connectionSettings) Parameters: Name Type Description connectionSettings object Settings of connecting Soundpad Source: index.js, line 19 Methods connect() Connects to Soundpad Source: index.js, line 44 Returns: Resolves the Soundpad instance when connected Soundpad successfully Type Promise disconnect() Disconnects Soundpad Source: index.js, line 81 Returns: Resolves the Soundpad instance when disconnected Soundpad successfully. Type Promise poll() Poll Soundpad Source: index.js, line 100 Returns: Resolves the Soundpad instance when Soundpad respond Type Promise send(data, hasResponse) Send data to Soundpad Parameters: Name Type Default Description data string | Buffer | Uint8Array Data which will be sent. hasResponse boolean false Wait until Soundpad respond? Source: index.js, line 119 Returns: Resolves response if hasResponse is true, or resolves the Soundpad instance when the data is sent Type Promise × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
